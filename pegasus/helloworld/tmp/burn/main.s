;
; File generated by cc65 v 2.13.3
;
	.fopt		compiler,"cc65 v 2.13.3"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank, tmp1, ptr1, ptr2
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_spr
	.import		_pal_col
	.import		_pal_bright
	.import		_ppu_on_all
	.import		_oam_meta_spr
	.import		_ppu_waitnmi
	.import		_pad_poll
	.import		_vram_adr
	.import		_vram_put
	.import		_vram_write
	.import		_memfill
	.import		_delay
	.export		_test
	.export		_palSprites
	.export		_put_str
	.export		_screen_fade_out
	.export		_screen_fade_in
	.export		_init_screen
	.export		_init
	.export		_is_pressed
	.export		_sprite
	.export		_main

.segment	"DATA"

_ball:
	.word	$0000
	.word	$0000
	.byte	$00
	.byte	$00
	.byte	$50
	.byte	$00
	.byte	$80
_rocket:
	.word	$0000
	.word	$0000
	.byte	$00
	.byte	$00
	.byte	$51
	.byte	$00
	.byte	$80

.segment	"RODATA"

_test:
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$A3
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$01
	.byte	$0A
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$04
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$06
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0C
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0C
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$08
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0C
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$42
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$06
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$04
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$04
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$06
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$04
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$06
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$01
	.byte	$06
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$04
	.byte	$10
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$01
	.byte	$04
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$06
	.byte	$10
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$04
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$06
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$06
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$01
	.byte	$46
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$01
	.byte	$0E
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0E
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$0E
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$10
	.byte	$01
	.byte	$04
	.byte	$00
	.byte	$01
	.byte	$0E
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$10
	.byte	$00
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$DE
	.byte	$50
	.byte	$01
	.byte	$07
	.byte	$55
	.byte	$01
	.byte	$07
	.byte	$A5
	.byte	$01
	.byte	$07
	.byte	$AA
	.byte	$01
	.byte	$0F
	.byte	$0A
	.byte	$01
	.byte	$07
	.byte	$01
	.byte	$00
_palSprites:
	.byte	$0F
	.byte	$17
	.byte	$27
	.byte	$37
	.byte	$0F
	.byte	$11
	.byte	$21
	.byte	$31
	.byte	$0F
	.byte	$15
	.byte	$25
	.byte	$35
	.byte	$0F
	.byte	$19
	.byte	$29
	.byte	$39

.segment	"BSS"

_vram_buffer:
	.res	896,$00
_spr:
	.res	1,$00
_prawo:
	.res	1,$00
_frame:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ put_str (unsigned int, __near__ const unsigned char*)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_put_str: near

.segment	"CODE"

;
; vram_adr(adr);
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_adr
;
; if(!*str) break;
;
L014C:	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	jeq     incsp4
;
; vram_put((*str++)-0x20); //-0x20 because ASCII code 0x20 is placed in tile 0 of the CHR
;
	iny
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0154
	inx
L0154:	jsr     stax0sp
	ldy     #$00
	lda     (regsave),y
	sec
	sbc     #$20
	jsr     _vram_put
;
; }
;
	jmp     L014C

.endproc

; ---------------------------------------------------------------
; void __near__ screen_fade_out (int)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_screen_fade_out: near

.segment	"CODE"

;
; unsigned char i=0x05;
;
	lda     #$05
	jsr     pusha
;
; i--;
;
L0158:	ldy     #$00
	lda     (sp),y
	sec
	sbc     #$01
	sta     (sp),y
;
; pal_bright(i);
;
	jsr     _pal_bright
;
; delay(interval);
;
	ldy     #$01
	lda     (sp),y
	jsr     _delay
;
; if (i==0){
;
	ldy     #$00
	lda     (sp),y
	bne     L0158
;
; break;
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ screen_fade_in (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_screen_fade_in: near

.segment	"CODE"

;
; unsigned char i=0x00;
;
	lda     #$00
	jsr     pusha
;
; i++;
;
L0164:	ldy     #$00
	lda     (sp),y
	clc
	adc     #$01
	sta     (sp),y
;
; pal_bright(i);
;
	jsr     _pal_bright
;
; delay(5);
;
	lda     #$05
	jsr     _delay
;
; if (i==4){
;
	ldy     #$00
	lda     (sp),y
	cmp     #$04
	bne     L0164
;
; break;
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ init_screen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_init_screen: near

.segment	"CODE"

;
; memfill(vram_buffer, 0, 896); // 896:32*28
;
	jsr     decsp3
	lda     #<(_vram_buffer)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_vram_buffer)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	ldx     #$03
	lda     #$80
	jsr     _memfill
;
; vram_write((unsigned char *)vram_buffer, NTADR(0, 1), 32 * 28);
;
	jsr     decsp4
	lda     #<(_vram_buffer)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_vram_buffer)
	sta     (sp),y
	lda     #$20
	ldy     #$00
	sta     (sp),y
	iny
	sta     (sp),y
	ldx     #$03
	lda     #$80
	jmp     _vram_write

.endproc

; ---------------------------------------------------------------
; void __near__ init (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_init: near

.segment	"CODE"

;
; pal_spr(palSprites);//set palette for sprites
;
	lda     #<(_palSprites)
	ldx     #>(_palSprites)
	jsr     _pal_spr
;
; pal_col(1,0x30);//set while color
;
	lda     #$01
	jsr     pusha
	lda     #$30
	jmp     _pal_col

.endproc

; ---------------------------------------------------------------
; int __near__ is_pressed (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_is_pressed: near

.segment	"CODE"

;
; i=pad_poll(0);
;
	jsr     decsp1
	lda     #$00
	jsr     _pad_poll
	ldy     #$00
	sta     (sp),y
;
; return i&pad;
;
	ldx     #$00
	iny
	lda     (sp),y
	dey
	and     (sp),y
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ sprite (__near__ struct $anon-struct-0001*)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_sprite: near

.segment	"CODE"

;
; spr=oam_meta_spr(data->x,data->y,spr,data->pattern);
;
	jsr     decsp3
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	ldy     #$02
	sta     (sp),y
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     ptr1
	stx     ptr1+1
	dey
	lda     (ptr1),y
	dey
	sta     (sp),y
	lda     _spr
	dey
	sta     (sp),y
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$04
	bcc     L019B
	inx
L019B:	jsr     _oam_meta_spr
	sta     _spr
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; init();
;
	jsr     _init
;
; prawo=0;
;
	lda     #$00
	sta     _prawo
;
; frame=0;
;
	sta     _frame
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; ppu_waitnmi(); //wait for next TV frame
;
L01A4:	jsr     _ppu_waitnmi
;
; if (frame==0){rocket.x=20;
;
	lda     _frame
	bne     L01A8
	tax
	lda     #$14
	sta     _rocket
	stx     _rocket+1
;
; rocket.y=20;
;
	sta     _rocket+2
	stx     _rocket+2+1
;
; frame=1;
;
	lda     #$01
	sta     _frame
;
; ball.y=15;
;
	lda     #$0F
	sta     _ball+2
	stx     _ball+2+1
;
; ball.x=60;} else {if (is_pressed(PAD_LEFT)){rocket.x-=1;} 
;
	lda     #$3C
	sta     _ball
	stx     _ball+1
	jmp     L01BB
L01A8:	lda     #$40
	jsr     pusha
	jsr     _is_pressed
	stx     tmp1
	ora     tmp1
	beq     L01B5
	lda     _rocket
	sec
	sbc     #$01
	sta     _rocket
	bcs     L01B5
	dec     _rocket+1
;
; if (is_pressed(PAD_RIGHT)){rocket.x+=1;}  } 
;
L01B5:	lda     #$80
	jsr     pusha
	jsr     _is_pressed
	stx     tmp1
	ora     tmp1
	beq     L01BB
	inc     _rocket
	bne     L01BB
	inc     _rocket+1
;
; sprite(&rocket);
;
L01BB:	lda     #<(_rocket)
	ldx     #>(_rocket)
	jsr     pushax
	jsr     _sprite
;
; }
;
	jmp     L01A4

.endproc

